# Project Constitution: Evolution of Todo – Full Hackathon II Journey (Phases 1–5)

## Vision
We are building **one single Todo application** that evolves iteratively across all five phases of Hackathon II.  
This is a continuous, spec-driven project — no phase is independent.

- Phase 1: In-memory Python console Todo app  
- Phase 2: Persistent full-stack web application (Next.js + FastAPI + Neon PostgreSQL)  
- Phase 3: AI-powered conversational chatbot (Google Gemini + LangChain + MCP-style tools)  
- Phase 4: Local Kubernetes deployment (Minikube + Helm + Docker + kubectl-ai + kagent)  
- Phase 5: Advanced cloud-native deployment (Oracle OKE / GKE / AKS + Kafka + Dapr + CI/CD)

Every phase **must build directly on the previous one** in the **same monorepo** without deleting, overwriting, or breaking any prior functionality.

## Core Guiding Principles (Apply to All Phases)
- **Spec-Driven Development Only**: No manual coding is permitted at any stage. All code (application logic, infrastructure, Dockerfiles, Helm charts, Dapr components, CI/CD workflows, etc.) must be generated by Claude from refined Markdown specifications and this constitution.
- **Iterative Evolution & Backward Compatibility**: Each phase extends the same application. All features and code from previous phases must remain fully functional and untouched.
- **Clean Architecture & Separation of Concerns**: Strict layering — presentation (frontend), business logic & API (backend), data (database), orchestration (Kubernetes), event-driven (Kafka + Dapr).
- **Simplicity, Extensibility & Reusability**: Minimal components designed for future phases (AI agents, containers, event-driven, cloud scaling).
- **User-Centric & Reliable**: The application must remain intuitive, responsive, and resilient at every stage.
- **Monorepo Structure**: Everything lives in **one single GitHub repository** with clear folder organization. **Never delete or modify files from previous phases.**
- **Preservation Rule**: All code, specs, configurations, and data models from Phases 1–4 must remain intact and operational in Phase 5 and beyond. Only add new files/folders.

## Phase-Specific Principles & Additions

### Phase 1 – In-Memory Console App
- Simple command-line Todo with 5 basic features (add, delete, update, view, mark complete).
- In-memory storage only.
- Technology: Python 3.13+, UV.

### Phase 2 – Full-Stack Web Application
- Persistent multi-user web app.
- Backend: FastAPI + SQLModel + Neon PostgreSQL.
- Frontend: Next.js (App Router) + TypeScript + Tailwind CSS.
- REST API for CRUD + intermediate features (priority, tags, search/filter/sort).
- No breaking changes to Phase 1 logic.

### Phase 3 – AI-Powered Todo Chatbot
- Conversational natural-language interface for all basic features.
- Use Google Gemini (gemini-1.5-flash/pro) + google-generativeai + LangChain for agentic logic and function calling.
- MCP-style stateless tools server (add_task, list_tasks, complete_task, delete_task, update_task).
- Stateless chat endpoint persisting conversation state in Neon DB (new models: Conversation, Message).
- Frontend: Add chat interface to existing Next.js app.
- No breaking changes to Phase 1 & 2 functionality.

### Phase 4 – Local Kubernetes Deployment
- Containerize frontend and backend.
- Use Docker (Docker Desktop) + Docker AI Agent (Gordon) where possible, or Claude-generated Dockerfiles.
- Create Helm charts for packaging and deployment.
- Deploy full application (frontend + backend + DB connection) on local Minikube cluster.
- Use **kubectl-ai** and **kagent** for AI-assisted Kubernetes operations (generate manifests, debug, optimize).
- Strict rule: Do not delete, modify, or remove any files/code from Phases 1–3. Only add new folders/files (e.g., docker/, charts/, k8s/).
- Goal: Running pods for frontend and backend visible via `kubectl get pods`, accessible locally.

### Phase 5 – Advanced Cloud Deployment
- Implement advanced features: recurring tasks, due dates & reminders.
- Add event-driven architecture with Kafka (Redpanda Cloud serverless or Strimzi self-hosted).
- Implement Dapr for distributed runtime: Pub/Sub (Kafka), State (Neon PostgreSQL), Jobs (reminders), Secrets, Service Invocation.
- Deploy to production-grade cloud Kubernetes: Oracle OKE (preferred always-free), Google GKE, or Azure AKS.
- Set up GitHub Actions CI/CD pipeline for automated build → deploy.
- Configure monitoring and logging (Prometheus/Grafana or cloud-native).
- Strict rule: Do not delete, modify, or remove any files/code from Phases 1–4. Only add new folders/files (e.g., cloud/, dapr/, kafka/, .github/workflows/, monitoring/).
- Goal: Full application running on cloud Kubernetes with event-driven scaling, CI/CD, and observability.

## Technology Stack – Cumulative (All Phases)

- **Base (All Phases)**:
  - Monorepo: Git + UV (Python) + npm/pnpm (frontend)
  - Database: Neon Serverless PostgreSQL (persists across all phases)

- **Phase 1**: Python 3.13+, UV

- **Phase 2**:
  - Backend: FastAPI, SQLModel, Uvicorn, psycopg2-binary, python-dotenv
  - Frontend: Next.js 14+, TypeScript, Tailwind CSS

- **Phase 3**:
  - AI: google-generativeai, langchain, langchain-google-genai, langchain-core
  - Environment: GEMINI_API_KEY

- **Phase 4**:
  - Containerization: Docker Desktop + Docker AI Agent (Gordon) or manual Dockerfiles
  - Orchestration: Kubernetes (Minikube)
  - Packaging: Helm
  - AIOps: kubectl-ai, kagent

- **Phase 5**:
  - Event-Driven: Kafka (Redpanda/Strimzi), kafka-python
  - Distributed Runtime: Dapr (sidecars, Pub/Sub, State, Jobs, Secrets)
  - Cloud: Oracle OKE / GKE / AKS CLI tools (oci/gcloud/az)
  - CI/CD: GitHub Actions
  - Monitoring/Logging: Prometheus, Grafana, cloud-native tools

## Data Model Evolution (Cumulative)
- **Phase 2 Task model** remains the core and **must not be modified or deleted**.
- **Phase 3 additions** (Conversation, Message) remain intact.
- **Phase 4**: No new models — only containerization and orchestration of existing app.
- **Phase 5**: No new models — only event-driven logic, Dapr integration, recurring/due-date logic on existing Task model.

## Constraints & Rules (All Phases)
- All new work must have corresponding Markdown specs in `/specs/` before implementation.
- Refine specifications iteratively until Claude generates correct, working code.
- **Never delete, rename, move, or modify any file from previous phases** — backward compatibility is mandatory.
- Environment-sensitive values (DATABASE_URL, GEMINI_API_KEY, cloud credentials) must stay in `.env` and never be committed.
- Code must follow PEP 8 (backend) and ESLint/Prettier (frontend).
- Error handling must be graceful.
- Phase 4 specific: Deployment must not break local development workflow.
- Phase 5 specific: Cloud deployment must not break local/Minikube workflow; CI/CD must be non-destructive.

## Repository Structure (Cumulative Monorepo – Do Not Change Existing Folders)
