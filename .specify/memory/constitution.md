# Project Constitution: Evolution of Todo - Phase 2 Full-Stack Web Application

## Vision
We are building a single Todo application that evolves iteratively across all hackathon phases.  
Phase 1 delivered an in-memory console application.  
Phase 2 transforms it into a persistent, multi-user, full-stack web application using modern cloud-native technologies — all driven strictly by specifications and AI-generated code.

The final goal remains a cloud-native AI-powered chatbot on Kubernetes (Phases 3–5), but every phase must build directly on the previous one in the same monorepo.

## Core Guiding Principles
- **Spec-Driven Development Only**: No manual coding is permitted at any stage. All implementation code must be generated by Claude from refined Markdown specifications and this constitution.
- **Iterative Evolution**: Each phase extends and enhances the same application. Phase 1 logic and data model serve as the foundation.
- **Clean Architecture**: Strict separation of concerns — backend handles data, business logic, and persistence; frontend handles presentation and user experience.
- **Simplicity & Extensibility**: Keep components minimal yet designed for future phases (AI agents, containerization, event-driven architecture).
- **User-Centric**: The application must remain intuitive and responsive at every stage.
- **Monorepo Structure**: Everything lives in one repository with clear folder organization.

## Phase 2 Specific Principles
- **Persistence**: Replace in-memory storage with Neon Serverless PostgreSQL.
- **Multi-User Ready**: Design data model and API to support future authentication and per-user tasks.
- **Full-Stack Separation**:
  - Backend: FastAPI + SQLModel for REST API and database operations.
  - Frontend: Next.js (App Router) with TypeScript and Tailwind CSS for responsive UI.
- **Feature Continuity**: Implement all 5 Basic Level features from Phase 1 (Add, Delete, Update, View, Mark Complete) via web interface. Add at least some Intermediate features (e.g., priority, tags, search/filter).
- **API-First**: Frontend consumes JSON REST API provided by backend.
- **Local Development**: Both backend and frontend must run simultaneously on localhost with hot reload.

## Technology Stack (Phase 2)
- **Backend**:
  - FastAPI
  - SQLModel (for models and ORM)
  - Uvicorn (development server)
  - psycopg2-binary (PostgreSQL driver)
  - python-dotenv (environment variables)
- **Database**:
  - Neon Serverless PostgreSQL (via DATABASE_URL in .env)
- **Frontend**:
  - Next.js 14+ (App Router)
  - TypeScript
  - Tailwind CSS
  - React Server Components where appropriate
- **Project Management**:
  - UV (for backend Python environment and dependencies)
  - npm/pnpm/yarn (for frontend)
- **Standard Library Only Where Possible**: No unnecessary external packages.

## Data Model Evolution
- Extend Phase 1 task structure:
  - `id`: Integer primary key (auto-generated)
  - `title`: String (required)
  - `description`: String (optional)
  - `completed`: Boolean (default False)
  - New fields for Phase 2:
    - `priority`: String/Enum ("high", "medium", "low", null)
    - `tags`: Array/String (e.g., "work", "personal")
    - `created_at`, `updated_at`: Timestamps
    - `user_id`: Integer (nullable now, required later for multi-user)

## Constraints & Rules
- All new features must have corresponding Markdown specs in `/specs/` before implementation.
- Refine specifications iteratively until Claude generates correct, working code.
- Backend must expose clean REST endpoints (e.g., GET /tasks, POST /tasks, etc.).
- Frontend must fetch and mutate data via these API endpoints (no direct DB access).
- Environment-sensitive values (DATABASE_URL) must stay in `.env` and never be committed.
- Code must follow PEP 8 (backend) and ESLint/Prettier standards (frontend).
- Error handling must be graceful on both client and server.

## Repository Structure (Monorepo)
hackathon-todo/
├── frontend/          ← Next.js TypeScript app (App Router, Tailwind)
├── backend/           ← FastAPI + SQLModel application
├── specs/             ← All specification history (Phase 1 + Phase 2 + future)
├── src/               ← Phase 1 console code (kept for historical reference)
├── constitution.md    ← This file (updated per major phase)
├── CLAUDE.md          ← Prompting guidelines for Claude
├── README.md          ← Project overview and run instructions
└── .env               ← Local only (DATABASE_URL, never commit)



## Development Workflow
1. Update/extend constitution (this file).
2. Write detailed specification (WHAT).
3. Create plan (HOW).
4. Break into atomic tasks.
5. Generate implementation via Claude Code (backend first, then frontend).
6. Test locally, refine specs if needed.
7. Commit with clear message linking to spec/task.

## Commitment
We adhere strictly to spec-driven development throughout the entire evolution.  
Every line of new code in Phase 2 and beyond shall originate from refined specifications interpreted by Claude — ensuring architectural integrity, traceability, and excellence worthy of Panaversity evaluation.

This constitution governs Phase 2 and will be further evolved in subsequent phases.